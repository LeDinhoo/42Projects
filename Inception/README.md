# Projet Inception : DÃ©ploiement de WordPress avec Docker

## Introduction

Ce projet, nommÃ© "Inception", consiste Ã  dÃ©ployer une infrastructure WordPress complÃ¨te utilisant Docker. L'architecture comprend trois services principaux : Nginx (serveur web), WordPress (application PHP), et MariaDB (base de donnÃ©es), chacun fonctionnant dans son propre conteneur Docker.

## PrÃ©requis

- Docker et Docker Compose installÃ©s sur votre systÃ¨me
- Make (pour utiliser le Makefile)
- Un systÃ¨me d'exploitation compatible (testÃ© sur Debian Buster)
- Au moins 8 Go d'espace disque disponible

# Sommaire

1. [Makefile](#makefile)
2. [Docker Compose](#docker-compose)
3. [Nginx](#nginx)
   1. [Dockerfile](#nginx-dockerfile)
   2. [Configuration](#nginx-configuration)
4. [MariaDB](#mariadb)
   1. [Dockerfile](#mariadb-dockerfile)
   2. [Script d'initialisation](#mariadb-init-script)
   3. [Configuration](#configuration-mariadb)
5. [WordPress](#wordpress)
   1. [Dockerfile](#wordpress-dockerfile)
   2. [Script d'initialisation](#wordpress-init-script)
   3. [Configuration PHP-FPM](#wordpress-php-fpm-configuration)

# Sommaire - Configuration de la Machine Virtuelle pour Inception

1. [TÃ©lÃ©chargement de l'image Debian](#1-tÃ©lÃ©chargement-de-limage-debian)
2. [CrÃ©ation et configuration de la machine virtuelle](#2-crÃ©ation-et-configuration-de-la-machine-virtuelle)
3. [DÃ©marrage de la VM et sÃ©lection de l'image Debian](#3-dÃ©marrage-de-la-vm-et-sÃ©lection-de-limage-debian)
4. [Installation de Debian](#4-installation-de-debian)
5. [Connexion en tant que root](#5-connexion-en-tant-que-root)
6. [Installation des paquets nÃ©cessaires et dÃ©marrage de l'environnement graphique](#6-installation-des-paquets-nÃ©cessaires-et-dÃ©marrage-de-lenvironnement-graphique)
7. [Configuration de SSH pour permettre la connexion root](#7-configuration-de-ssh-pour-permettre-la-connexion-root)
8. [Configuration du pare-feu UFW](#8-configuration-du-pare-feu-ufw)
9. [Configuration de la redirection de ports et connexion SSH Ã  distance](#9-configuration-de-la-redirection-de-ports-et-connexion-ssh-Ã -distance)
   1. [Configuration de la redirection de ports dans VirtualBox](#91-configuration-de-la-redirection-de-ports-dans-virtualbox)
   2. [VÃ©rification du service SSH et connexion Ã  distance](#92-vÃ©rification-du-service-ssh-et-connexion-Ã -distance)
10. [Configuration de sudo et ajout de l'utilisateur au groupe Docker](#10-configuration-de-sudo-et-ajout-de-lutilisateur-au-groupe-docker)
    1. [Configuration de sudo](#101-configuration-de-sudo)
    2. [Ajout de l'utilisateur au groupe Docker](#102-ajout-de-lutilisateur-au-groupe-docker)
11. [Test de la configuration et clonage du projet Inception](#11-test-de-la-configuration-et-clonage-du-projet-inception)
    1. [Passage Ã  l'utilisateur normal](#111-passage-Ã -lutilisateur-normal)
    2. [Clonage du projet Inception](#112-clonage-du-projet-inception)
12. [Lancement du projet Inception avec Docker Compose](#12-lancement-du-projet-inception-avec-docker-compose)


## Structure du projet
```
ğŸ“¦inception
 â”£ ğŸ“‚srcs
 â”ƒ â”£ ğŸ“‚requirements
 â”ƒ â”ƒ â”£ ğŸ“‚mariadb
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œ50-server.conf
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œDockerfile
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œinit.sh
 â”ƒ â”ƒ â”£ ğŸ“‚nginx
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œDockerfile
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œnginx.conf
 â”ƒ â”ƒ â”— ğŸ“‚wordpress
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œDockerfile
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œinit.sh
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œwww.conf
 â”ƒ â”£ ğŸ“œ.env
 â”ƒ â”— ğŸ“œdocker-compose.yml
 â”— ğŸ“œMakefile
```

# Makefile

## Explication du Makefile

### Variables

```makefile
VOLUME_DIR = /home/$(USER)/data
WP_DIR = $(VOLUME_DIR)/wordpress
DB_DIR = $(VOLUME_DIR)/mariadb
DOCKER_FILE = ./srcs/docker-compose.yml
```

- `VOLUME_DIR` : Chemin du rÃ©pertoire de donnÃ©es de l'utilisateur.
- `WP_DIR` : Chemin du rÃ©pertoire WordPress dans le volume.
- `DB_DIR` : Chemin du rÃ©pertoire MariaDB dans le volume.
- `DOCKER_FILE` : Chemin du fichier docker-compose.yml.

### Cibles factices

```makefile
.PHONY: all up down re clean fclean
```

DÃ©clare que ces cibles ne correspondent pas Ã  des fichiers rÃ©els.

### Cible par dÃ©faut

```makefile
all: up
```

ExÃ©cute la cible 'up' par dÃ©faut.

### CrÃ©ation des rÃ©pertoires

```makefile
$(VOLUME_DIR) $(WP_DIR) $(DB_DIR):
	mkdir -p $@
```

CrÃ©e les rÃ©pertoires nÃ©cessaires s'ils n'existent pas.

### Cible 'up'

```makefile
up: $(WP_DIR) $(DB_DIR)
	docker-compose -f $(DOCKER_FILE) up --build
```

- DÃ©pend de la crÃ©ation des rÃ©pertoires WP_DIR et DB_DIR.
- Lance les conteneurs avec docker-compose en mode dÃ©tachÃ© et reconstruit les images.

### Cible 'down'

```makefile
down:
	docker-compose -f $(DOCKER_FILE) down
```

ArrÃªte et supprime les conteneurs dÃ©finis dans le fichier docker-compose.

### Cible 're'

```makefile
re: down up
```

ExÃ©cute 'down' puis 'up' pour redÃ©marrer les conteneurs.

### Cible 'clean'

```makefile
clean: down
	docker system prune -af --volumes
	sudo rm -rf $(WP_DIR) $(DB_DIR) $(VOLUME_DIR)
```

- ArrÃªte les conteneurs.
- Supprime tous les conteneurs, rÃ©seaux et volumes docker non utilisÃ©s.
- Supprime les rÃ©pertoires de donnÃ©es.

### Cible 'fclean'

```makefile
fclean: clean
	docker builder prune --all -f
```

- ExÃ©cute 'clean'.
- Supprime tous les caches de construction Docker.

Ce Makefile est conÃ§u pour gÃ©rer un environnement Docker contenant WordPress et MariaDB. Il offre des commandes pour dÃ©marrer, arrÃªter, nettoyer et reconstruire l'environnement facilement.

# Docker Compose

Je vais vous expliquer en dÃ©tail ce fichier docker-compose.yml que j'ai crÃ©Ã© pour notre projet Inception. Ce fichier dÃ©finit l'architecture de notre application, qui se compose de trois services principaux : nginx, WordPress et MariaDB. Voici une explication approfondie de chaque section :

## Services

### 1. Service nginx

```yaml
nginx:
  restart: always
  container_name: nginx
  build:
    dockerfile: Dockerfile
    context: ./requirements/nginx
  volumes:
    - wordpress:/var/www/html
  networks:
    - inception_network
  env_file:
    - .env
  ports:
    - "443:443"
  depends_on:
    - wordpress
```

- `restart: always` : Cette option assure que le conteneur nginx redÃ©marre automatiquement en cas d'arrÃªt, mÃªme aprÃ¨s un redÃ©marrage de l'hÃ´te Docker. C'est crucial pour maintenir la disponibilitÃ© de notre serveur web.
- `build` : SpÃ©cifie comment construire l'image Docker pour nginx. Le Dockerfile se trouve dans `./requirements/nginx`.
- `volumes` : Monte le volume 'wordpress' dans le conteneur, permettant Ã  nginx d'accÃ©der aux fichiers WordPress.
- `networks` : Connecte le conteneur au rÃ©seau 'inception_network'.
- `env_file` : Utilise les variables d'environnement dÃ©finies dans le fichier .env.
- `ports` : Expose le port 443 (HTTPS) du conteneur vers l'hÃ´te.
- `depends_on` : Indique que nginx dÃ©pend du service WordPress, assurant que WordPress dÃ©marre avant nginx.

### 2. Service WordPress

```yaml
wordpress:
  restart: always
  container_name: wordpress
  build:
    dockerfile: Dockerfile
    context: ./requirements/wordpress
  volumes:
    - wordpress:/var/www/html
  networks:
    - inception_network
  env_file:
    - .env
  ports:
    - 9000:9000
  depends_on:
    - mariadb
```

La configuration est similaire Ã  celle de nginx, avec quelques diffÃ©rences clÃ©s :
- `ports` : Expose le port 9000, utilisÃ© par PHP-FPM pour communiquer avec nginx.
- `depends_on` : WordPress dÃ©pend de MariaDB, assurant que la base de donnÃ©es est prÃªte avant le dÃ©marrage de WordPress.

### 3. Service MariaDB

```yaml
mariadb:
  restart: always
  container_name: mariadb
  build:
    dockerfile: Dockerfile
    context: ./requirements/mariadb
  volumes:
    - mariadb:/var/lib/mysql
  networks:
    - inception_network
  env_file:
    - .env
  ports:
    - 3306:3306
```

La configuration de MariaDB est similaire aux autres services, avec une diffÃ©rence notable :
- `volumes` : Utilise un volume spÃ©cifique 'mariadb' pour stocker les donnÃ©es de la base de donnÃ©es, assurant leur persistance.

## Networks

```yaml
networks:
  inception_network:
    driver: bridge
```

J'ai dÃ©fini un rÃ©seau nommÃ© 'inception_network' utilisant le driver 'bridge'. Ce type de rÃ©seau crÃ©e un rÃ©seau privÃ© interne Ã  l'hÃ´te Docker, permettant aux conteneurs de communiquer entre eux tout en les isolant du rÃ©seau de l'hÃ´te. C'est idÃ©al pour notre configuration car cela offre une sÃ©curitÃ© accrue et une isolation appropriÃ©e.

## Volumes

```yaml
volumes:
  mariadb:
    name: mariadb
    driver: local
    driver_opts:
      o: bind
      type: none
      device: /home/dupuy/data/mariadb

  wordpress:
    name: wordpress
    driver: local
    driver_opts:
      o: bind
      type: none
      device: /home/dupuy/data/wordpress
```

J'ai dÃ©fini deux volumes pour la persistance des donnÃ©es :

1. `mariadb` : Pour stocker les donnÃ©es de la base de donnÃ©es.
2. `wordpress` : Pour stocker les fichiers WordPress.

Pour chaque volume :
- `driver: local` indique que le volume sera stockÃ© sur le systÃ¨me de fichiers local de l'hÃ´te Docker.
- Les `driver_opts` sont configurÃ©es pour monter directement des rÃ©pertoires de l'hÃ´te dans les conteneurs (bind mount). Cela permet un accÃ¨s facile aux fichiers depuis l'hÃ´te, ce qui est particuliÃ¨rement utile pour le dÃ©veloppement et le dÃ©bogage.

Cette configuration assure que les donnÃ©es persistent mÃªme si les conteneurs sont arrÃªtÃ©s ou supprimÃ©s, et permet une gestion facile des fichiers directement depuis l'hÃ´te.

# Nginx

## Nginx Dockerfile

Je vais vous expliquer en dÃ©tail le Dockerfile que j'ai crÃ©Ã© pour le service Nginx de notre projet Inception. Ce fichier dÃ©finit comment construire l'image Docker pour notre serveur web Nginx. Voici une explication approfondie de chaque instruction :

```dockerfile
FROM debian:buster
```
J'ai choisi Debian Buster comme image de base pour sa stabilitÃ© et son support Ã  long terme. Bien qu'une version plus rÃ©cente pourrait offrir des packages plus Ã  jour, Buster offre un bon Ã©quilibre entre stabilitÃ© et actualitÃ© des packages.

```dockerfile
RUN apt-get update -y && apt-get -y upgrade
```
Cette commande met Ã  jour la liste des paquets disponibles et effectue une mise Ã  niveau du systÃ¨me. C'est une bonne pratique pour s'assurer que nous travaillons avec les derniÃ¨res versions des paquets.

```dockerfile
RUN apt-get install -y openssl
```
J'installe OpenSSL pour la gestion des certificats SSL/TLS. OpenSSL est essentiel pour gÃ©nÃ©rer et gÃ©rer les certificats nÃ©cessaires au HTTPS. Bien qu'il existe des alternatives comme LibreSSL ou GnuTLS, OpenSSL reste le choix le plus courant et le mieux supportÃ©.

```dockerfile
RUN apt-get install -y nginx
```
Ici, j'installe le serveur web Nginx. J'ai choisi Nginx pour sa lÃ©gÃ¨retÃ© et ses performances, particuliÃ¨rement efficace pour servir du contenu statique et comme proxy inverse. Son architecture Ã©vÃ©nementielle non-bloquante lui permet de gÃ©rer efficacement de nombreuses connexions simultanÃ©es avec une faible empreinte mÃ©moire.

```dockerfile
RUN mkdir -p /etc/nginx/ssl
RUN chmod 777 /etc/nginx/ssl
```
Je crÃ©e un rÃ©pertoire pour stocker les certificats SSL et lui attribue des permissions larges (777). Dans un environnement de production, il serait prÃ©fÃ©rable d'utiliser des permissions plus restrictives (comme 750) et de s'assurer que seuls les utilisateurs nÃ©cessaires y ont accÃ¨s.

```dockerfile
RUN openssl req -newkey rsa:4096 -x509 -sha256 -days 365 -nodes \
       -out /etc/nginx/ssl/server.crt \
       -keyout /etc/nginx/ssl/server.key \
       -subj "/C=FR/ST=Rhone/L=Lyon/O=42_School/OU=42_Lyon/CN=hdupuy.42.fr"
```
Cette commande gÃ©nÃ¨re un certificat SSL auto-signÃ©. Bien que pratique pour le dÃ©veloppement, un tel certificat n'est pas reconnu par les navigateurs et ne devrait pas Ãªtre utilisÃ© en production. Dans un environnement de production, il faudrait obtenir un certificat d'une autoritÃ© reconnue (comme Let's Encrypt) et le configurer correctement.

```dockerfile
COPY nginx.conf /etc/nginx/conf.d/default.conf
```
Je copie le fichier de configuration Nginx dans le conteneur. Ce fichier dÃ©finit probablement les paramÃ¨tres du serveur HTTPS, les chemins des certificats SSL, et d'autres configurations spÃ©cifiques Ã  notre application.

```dockerfile
EXPOSE 443
```
J'indique que le conteneur utilisera le port 443 (HTTPS). Si nous voulions gÃ©rer aussi le trafic HTTP et le rediriger vers HTTPS, nous pourrions exposer le port 80 et configurer Nginx en consÃ©quence.

```dockerfile
CMD [ "nginx", "-g", "daemon off;" ]
```
Enfin, je dÃ©marre Nginx en mode premier plan avec l'option "daemon off". Cette approche est prÃ©fÃ©rable dans un environnement conteneurisÃ© car elle permet Ã  Docker de gÃ©rer correctement le cycle de vie du processus, facilite la collecte des logs, et assure que le conteneur s'arrÃªte proprement si Nginx s'arrÃªte.


## Nginx Configuration

Je vais vous expliquer en dÃ©tail ce fichier de configuration Nginx que j'ai crÃ©Ã© pour notre projet Inception. Ce fichier dÃ©finit comment notre serveur Nginx doit gÃ©rer les requÃªtes entrantes pour notre application WordPress. Voici une explication approfondie de chaque section :

```nginx
server {
    listen 443 ssl;
    listen [::]:443 ssl;
```
Ces lignes configurent le serveur pour Ã©couter les connexions HTTPS sur le port 443, Ã  la fois pour IPv4 et IPv6. C'est essentiel pour assurer que toutes les connexions Ã  notre site sont sÃ©curisÃ©es via SSL/TLS.

```nginx
    root /var/www/html;
```
Cette ligne dÃ©finit le rÃ©pertoire racine oÃ¹ Nginx cherchera les fichiers Ã  servir. C'est le rÃ©pertoire standard pour les fichiers web dans de nombreuses configurations, et il correspond probablement au point de montage de notre volume WordPress.

```nginx
    index index.php index.html index.htm;
```
Ceci spÃ©cifie l'ordre de prioritÃ© des fichiers index. Nginx cherchera d'abord index.php, puis index.html, et enfin index.htm. Cette configuration est optimale pour WordPress, qui utilise principalement des fichiers PHP.

```nginx
    server_name hdupuy.42.fr;
```
Cette ligne dÃ©finit le nom de domaine du serveur. C'est crucial pour que Nginx sache quel bloc server utiliser pour les requÃªtes adressÃ©es Ã  ce domaine spÃ©cifique.

```nginx
    ssl_certificate     /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
```
Ces lignes spÃ©cifient l'emplacement du certificat SSL et de sa clÃ© privÃ©e. Ces fichiers sont essentiels pour Ã©tablir des connexions HTTPS sÃ©curisÃ©es.

```nginx
    ssl_protocols       TLSv1.2 TLSv1.3;
```
Cette directive dÃ©finit les protocoles SSL/TLS autorisÃ©s. TLSv1.2 et TLSv1.3 sont actuellement les versions les plus sÃ©curisÃ©es et recommandÃ©es.

```nginx
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
```
Ce bloc gÃ¨re les requÃªtes pour la racine du site. La directive `try_files` permet de servir des fichiers statiques directement, ou de passer Ã  WordPress si aucun fichier n'est trouvÃ©.

```nginx
    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass wordpress:9000;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
    }
```
Ce bloc gÃ¨re les requÃªtes pour les fichiers PHP. Il inclut la configuration FastCGI standard pour PHP, puis passe les requÃªtes PHP au service WordPress sur le port 9000. Cela permet Ã  Nginx de communiquer avec le processus PHP-FPM dans le conteneur WordPress. La directive `fastcgi_split_path_info` est nÃ©cessaire pour le bon fonctionnement de certains scripts PHP, notamment dans WordPress.


# MariaDB

## MariaDB Dockerfile

Je vais vous expliquer en dÃ©tail ce Dockerfile que j'ai crÃ©Ã© pour le service MariaDB de notre projet Inception. Ce fichier dÃ©finit comment construire l'image Docker pour notre serveur de base de donnÃ©es. Voici une explication approfondie de chaque instruction :

```dockerfile
FROM debian:buster
```
J'ai choisi Debian Buster comme image de base pour sa stabilitÃ© et sa compatibilitÃ© avec MariaDB. Cette version de Debian offre un bon Ã©quilibre entre stabilitÃ© et actualitÃ© des packages.

```dockerfile
RUN apt-get update -y && apt-get -y upgrade
RUN apt-get install -y mariadb-server
```
Ces commandes mettent Ã  jour le systÃ¨me et installent MariaDB Server. J'utilise l'option `-y` pour automatiser les rÃ©ponses aux prompts d'installation, ce qui est nÃ©cessaire dans un environnement Docker non interactif.

```dockerfile
COPY init.sh init.sh
COPY 50-server.conf /etc/mysql/mariadb.conf.d/50-server.cnf
```
Je copie deux fichiers importants dans le conteneur :
1. `init.sh` : un script d'initialisation pour configurer et dÃ©marrer MariaDB.
2. `50-server.conf` : un fichier de configuration personnalisÃ© pour MariaDB.

```dockerfile
RUN chmod +x /init.sh
RUN chmod 600 /etc/mysql/mariadb.conf.d/50-server.cnf
```
Je configure les permissions des fichiers copiÃ©s. Le script `init.sh` est rendu exÃ©cutable, et le fichier de configuration MariaDB reÃ§oit des permissions restrictives (600) pour des raisons de sÃ©curitÃ©.

```dockerfile
RUN mkdir -p /var/run/mysqld
RUN chmod 777 /var/run/mysqld
```
Je prÃ©pare l'environnement pour l'exÃ©cution de MariaDB en crÃ©ant le rÃ©pertoire `/var/run/mysqld` et en lui attribuant des permissions permissives. Bien que 777 soit nÃ©cessaire pour le fonctionnement de MariaDB dans ce contexte, il faut noter que ces permissions larges pourraient Ãªtre considÃ©rÃ©es comme un risque de sÃ©curitÃ© dans certains environnements.

```dockerfile
EXPOSE 3306
```
Cette instruction informe Docker que le conteneur Ã©coutera sur le port 3306, qui est le port standard utilisÃ© par MariaDB pour les connexions client.

```dockerfile
ENTRYPOINT [ "/init.sh" ]
```
Je dÃ©finis le point d'entrÃ©e du conteneur comme Ã©tant le script `init.sh`. Ce script sera responsable de l'initialisation et du dÃ©marrage de MariaDB lorsque le conteneur dÃ©marrera.

Quelques points supplÃ©mentaires Ã  considÃ©rer :

1. SÃ©curitÃ© : L'utilisation de `chmod 600` pour le fichier de configuration est une bonne pratique, mais les permissions 777 sur `/var/run/mysqld` pourraient Ãªtre affinÃ©es.

2. Configuration : Le contenu du fichier `50-server.conf` devrait Ãªtre examinÃ© pour s'assurer qu'il suit les meilleures pratiques de configuration de MariaDB.

3. Initialisation : Le script `init.sh` joue un rÃ´le crucial. Il devrait configurer la base de donnÃ©es initiale, crÃ©er les utilisateurs et les bases de donnÃ©es nÃ©cessaires, appliquer les paramÃ¨tres de sÃ©curitÃ©, et dÃ©marrer le service MariaDB.

4. Optimisation : Les commandes RUN pourraient Ãªtre combinÃ©es pour rÃ©duire le nombre de couches dans l'image Docker, amÃ©liorant ainsi lÃ©gÃ¨rement les performances et rÃ©duisant la taille de l'image.

5. Mise Ã  jour et maintenance : L'utilisation de Debian:buster implique que les mises Ã  jour de sÃ©curitÃ© dÃ©pendent de la maintenance de cette image. Une stratÃ©gie de mise Ã  jour rÃ©guliÃ¨re devrait Ãªtre envisagÃ©e.

6. Environnement de production : Pour un dÃ©ploiement en production, des considÃ©rations supplÃ©mentaires seraient nÃ©cessaires, comme la gestion des sauvegardes, la journalisation, et l'utilisation de secrets pour les mots de passe.

## MariaDB Init Script

Je vais vous expliquer en dÃ©tail ce script bash que j'ai crÃ©Ã© pour initialiser et configurer notre base de donnÃ©es MariaDB dans le contexte de notre projet Inception. Ce script est crucial pour la mise en place correcte de notre environnement de base de donnÃ©es. Voici une explication approfondie de chaque section :

```bash
#!/bin/bash
```
Cette ligne, appelÃ©e "shebang", indique que ce script doit Ãªtre exÃ©cutÃ© par le shell bash.

```bash
chown -R mysql:mysql /var/lib/mysql
mysql_install_db --datadir=/var/lib/mysql --user=mysql --skip-test-db >> /dev/null
```
Ces commandes prÃ©parent l'environnement pour MariaDB :
- `chown` change le propriÃ©taire du rÃ©pertoire de donnÃ©es de MariaDB pour s'assurer que l'utilisateur mysql a les bonnes permissions.
- `mysql_install_db` initialise le rÃ©pertoire de donnÃ©es de MariaDB. L'option `--skip-test-db` Ã©vite la crÃ©ation de bases de donnÃ©es de test inutiles.

```bash
echo "Initiating database"
mysqld --user=mysql --bootstrap --silent-startup << _EOF_
# ... (commandes SQL)
_EOF_
```
Cette section utilise la technique "here document" pour passer un script SQL directement Ã  mysqld en mode bootstrap. Ce mode permet d'exÃ©cuter des commandes SQL sans dÃ©marrer complÃ¨tement le serveur MySQL.

Les commandes SQL exÃ©cutÃ©es sont :

```sql
FLUSH PRIVILEGES;

CREATE DATABASE IF NOT EXISTS `${MYSQL_DTBS_NAME}`;
CREATE USER IF NOT EXISTS `${MYSQL_USER_NAME}`@'%' IDENTIFIED BY '${MYSQL_USER_PSWD}';
GRANT ALL PRIVILEGES ON `${MYSQL_DTBS_NAME}`.* TO `${MYSQL_USER_NAME}`@'%';

ALTER USER `root`@`localhost` IDENTIFIED BY '${MYSQL_ROOT_PSWD}';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;

FLUSH PRIVILEGES;
```

Ces commandes :
1. RÃ©initialisent les privilÃ¨ges.
2. CrÃ©ent la base de donnÃ©es spÃ©cifiÃ©e par la variable d'environnement `MYSQL_DTBS_NAME`.
3. CrÃ©ent un utilisateur avec le nom et le mot de passe spÃ©cifiÃ©s par les variables d'environnement.
4. Accordent tous les privilÃ¨ges Ã  cet utilisateur sur la base de donnÃ©es crÃ©Ã©e.
5. Modifient le mot de passe de l'utilisateur root.
6. Accordent tous les privilÃ¨ges Ã  root sur toutes les bases de donnÃ©es.
7. RafraÃ®chissent Ã  nouveau les privilÃ¨ges pour s'assurer que tous les changements sont pris en compte.

```bash
echo "Database initiated"
exec mysqld_safe
```
Ces lignes finales indiquent que l'initialisation est terminÃ©e et lancent le serveur MariaDB en utilisant `mysqld_safe`, qui est un script de dÃ©marrage recommandÃ© pour MariaDB en production.

Quelques points importants Ã  noter :
- L'utilisation de variables d'environnement (`${MYSQL_DTBS_NAME}`, etc.) permet une configuration flexible du script.
- Le script gÃ¨re Ã  la fois la crÃ©ation initiale de la base de donnÃ©es et la configuration des utilisateurs.
- L'utilisation de `IF NOT EXISTS` dans les commandes SQL assure que le script peut Ãªtre exÃ©cutÃ© plusieurs fois sans erreur.
- Le script accorde des privilÃ¨ges larges, ce qui pourrait nÃ©cessiter des ajustements pour un environnement de production plus sÃ©curisÃ©.


## Configuration MariaDB

Je comprends, voici l'explication dans le format que j'utilisais prÃ©cÃ©demment :

Ce fichier de configuration MariaDB, que j'ai crÃ©Ã© pour notre projet Inception, dÃ©finit les paramÃ¨tres de base pour notre serveur MariaDB. Voici une explication dÃ©taillÃ©e de chaque ligne :

```
[mysqld]
```
Cette section dÃ©finit les paramÃ¨tres pour le dÃ©mon MySQL (mysqld), qui est le processus serveur principal de MariaDB.

```
user = mysql
```
Cette ligne dÃ©finit l'utilisateur systÃ¨me sous lequel le serveur MariaDB s'exÃ©cutera. L'utilisation de l'utilisateur 'mysql' est une pratique standard pour des raisons de sÃ©curitÃ©.

```
port = 3306
```
Ceci spÃ©cifie le port sur lequel MariaDB Ã©coutera les connexions. 3306 est le port standard pour MySQL/MariaDB.

```
datadir = /var/lib/mysql
```
Cette ligne indique le rÃ©pertoire oÃ¹ MariaDB stockera ses fichiers de donnÃ©es. Ce chemin est standard dans la plupart des installations Linux.

```
socket = /var/run/mysqld/mysqld.sock
```
Ceci dÃ©finit l'emplacement du fichier socket Unix pour les connexions locales. Ce socket permet une communication efficace entre le serveur et les clients sur la mÃªme machine.

```
bind-address=*
```
Cette ligne permet au serveur d'Ã©couter les connexions sur toutes les interfaces rÃ©seau. L'astÃ©risque (*) signifie "toutes les adresses IP". C'est nÃ©cessaire dans un environnement conteneurisÃ© pour permettre les connexions depuis d'autres conteneurs.

Quelques points supplÃ©mentaires Ã  noter :
- Cette configuration est minimaliste et adaptÃ©e Ã  un environnement de dÃ©veloppement conteneurisÃ©.
- Pour un environnement de production, des paramÃ¨tres supplÃ©mentaires seraient nÃ©cessaires, notamment pour la sÃ©curitÃ© et les performances.
- L'option `bind-address=*` devrait Ãªtre utilisÃ©e avec prÃ©caution dans un environnement de production, car elle ouvre le serveur Ã  des connexions depuis n'importe quelle adresse IP.

Cette configuration Ã©tablit les bases pour notre serveur MariaDB, le rendant accessible depuis d'autres conteneurs dans notre environnement Docker tout en maintenant une structure de fichiers standard. Elle est conÃ§ue pour fonctionner de maniÃ¨re cohÃ©rente avec les autres composants de notre projet Inception, notamment le Dockerfile MariaDB et le script d'initialisation que nous avons discutÃ©s prÃ©cÃ©demment.

# WordPress

## Wordpress Dockerfile

Je vais vous expliquer en dÃ©tail ce Dockerfile que j'ai crÃ©Ã© pour le service WordPress de notre projet Inception. Ce fichier dÃ©finit comment construire l'image Docker pour notre serveur WordPress. Voici une explication approfondie de chaque instruction :

```dockerfile
FROM debian:buster
```
J'ai choisi Debian Buster comme image de base pour sa stabilitÃ© et sa compatibilitÃ©. Cette version de Debian offre un bon Ã©quilibre entre stabilitÃ© et actualitÃ© des packages.

```dockerfile
ENV DEBIAN_FRONTEND noninteractive
```
Cette ligne configure l'interface utilisateur de Debian en mode non-interactif, ce qui Ã©vite les prompts interactifs lors de l'installation des paquets et pourrait bloquer le build.

```dockerfile
RUN apt-get -y update && apt-get -y upgrade
```
Ces commandes mettent Ã  jour la liste des paquets et effectuent une mise Ã  niveau du systÃ¨me, assurant que nous travaillons avec les derniÃ¨res versions des paquets.

```dockerfile
RUN apt-get -y install \
    wget \
    php-fpm \
    php-mysql \
    mariadb-client
```
Cette instruction installe les paquets nÃ©cessaires :
- wget : pour tÃ©lÃ©charger WP-CLI
- php-fpm : pour exÃ©cuter PHP
- php-mysql : pour la connexion PHP Ã  MySQL/MariaDB
- mariadb-client : pour les interactions avec la base de donnÃ©es depuis le conteneur

```dockerfile
COPY www.conf /etc/php/7.3/fpm/pool.d/
```
Je copie un fichier de configuration personnalisÃ© pour PHP-FPM, permettant d'ajuster la configuration selon nos besoins spÃ©cifiques.

```dockerfile
RUN wget https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
RUN chmod +x wp-cli.phar
RUN mv wp-cli.phar /usr/local/bin/wp
```
Ces commandes installent WP-CLI, un outil en ligne de commande pour gÃ©rer WordPress. WP-CLI est crucial pour automatiser l'installation, la configuration et la maintenance de WordPress dans un environnement conteneurisÃ©.

### RÃ©sumÃ© de WP-CLI

WP-CLI (WordPress Command Line Interface) est un outil en ligne de commande qui permet d'interagir et de gÃ©rer une installation WordPress sans passer par l'interface graphique. Il est particuliÃ¨rement utile pour les dÃ©veloppeurs et administrateurs systÃ¨me qui souhaitent automatiser des tÃ¢ches rÃ©pÃ©titives, dÃ©ployer des sites rapidement, et effectuer des opÃ©rations de maintenance de maniÃ¨re efficace.

### FonctionnalitÃ©s principales

- **Installation et configuration** : Installez et configurez WordPress rapidement.
- **Gestion des plugins et thÃ¨mes** : Installez, activez, dÃ©sactivez et mettez Ã  jour les plugins et thÃ¨mes.
- **Gestion des utilisateurs** : Ajoutez, supprimez et mettez Ã  jour les utilisateurs.
- **Mises Ã  jour** : Mettez Ã  jour WordPress core, plugins et thÃ¨mes facilement.
- **Base de donnÃ©es** : Effectuez des sauvegardes, des restaurations et des opÃ©rations de maintenance sur la base de donnÃ©es.
- **Options du site** : GÃ©rez les options du site WordPress.

### Deux exemples de commande

1. **Installation de WordPress**

   Cette commande tÃ©lÃ©charge et configure WordPress en spÃ©cifiant les informations de base du site et de l'administrateur.

   ```sh
   wp core install --url="http://example.com" --title="Example Site" --admin_user="admin" --admin_password="password" --admin_email="email@example.com" --allow-root
   ```

   - `--url` : L'URL du site WordPress.
   - `--title` : Le titre du site.
   - `--admin_user` : Le nom d'utilisateur de l'administrateur.
   - `--admin_password` : Le mot de passe de l'administrateur.
   - `--admin_email` : L'email de l'administrateur.

2. **Installation et activation d'un plugin**

   Cette commande installe le plugin Akismet et l'active immÃ©diatement.

   ```sh
   wp plugin install akismet --activate --allow-root
   ```

   - `install akismet` : TÃ©lÃ©charge et installe le plugin Akismet.
   - `--activate` : Active le plugin immÃ©diatement aprÃ¨s l'installation.

### Avantages de WP-CLI

- **Automatisation** : Facilite l'automatisation des tÃ¢ches courantes, ce qui rÃ©duit les erreurs et Ã©conomise du temps.
- **EfficacitÃ©** : Permet des opÃ©rations rapides et efficaces, surtout lors de la gestion de multiples sites WordPress.
- **ScriptabilitÃ©** : Les commandes peuvent Ãªtre intÃ©grÃ©es dans des scripts pour des dÃ©ploiements et des maintenances automatisÃ©s.
- **AccÃ¨s direct** : Offre un accÃ¨s direct Ã  des fonctionnalitÃ©s avancÃ©es de WordPress sans nÃ©cessiter d'interface utilisateur graphique.

WP-CLI est un outil puissant pour quiconque travaille avec WordPress, offrant des fonctionnalitÃ©s complÃ¨tes pour la gestion, le dÃ©ploiement, et la maintenance des sites WordPress via la ligne de commande.

```dockerfile
COPY init.sh /init.sh
RUN chmod +x /init.sh
```
Je copie un script d'initialisation et le rends exÃ©cutable. Ce script sera probablement utilisÃ© pour configurer WordPress au dÃ©marrage du conteneur.

```dockerfile
EXPOSE 9000
```
Cette ligne expose le port 9000, sur lequel PHP-FPM Ã©coute par dÃ©faut, permettant la communication avec Nginx.

```dockerfile
WORKDIR /var/www/html/
```
Je dÃ©finis le rÃ©pertoire de travail comme Ã©tant l'emplacement standard pour les fichiers web.

```dockerfile
ENTRYPOINT [ "/init.sh" ]
```
Enfin, je dÃ©finis le point d'entrÃ©e du conteneur comme Ã©tant le script d'initialisation, qui sera exÃ©cutÃ© au dÃ©marrage du conteneur.

Points importants Ã  noter :
1. L'utilisation de WP-CLI permet une configuration automatisÃ©e et reproductible, idÃ©ale pour les environnements conteneurisÃ©s.
2. La configuration de PHP-FPM est personnalisÃ©e pour s'adapter Ã  nos besoins spÃ©cifiques.
3. Le script d'initialisation joue un rÃ´le crucial dans la configuration de WordPress au dÃ©marrage du conteneur.

Ce Dockerfile crÃ©e une image Docker contenant une installation de WordPress prÃªte Ã  l'emploi, configurÃ©e pour fonctionner avec PHP-FPM et communiquer avec notre service MariaDB. Il offre une base solide et flexible pour notre service WordPress dans le projet Inception.

## WordPress Init Script

Je vais vous expliquer en dÃ©tail ce script bash que j'ai crÃ©Ã© pour initialiser et configurer WordPress dans notre environnement conteneurisÃ© pour le projet Inception. Voici une explication approfondie de chaque section :

```bash
if [ ! -d /run/php ]
then
    service php7.3-fpm start
    service php7.3-fpm stop
fi
```
Cette section crÃ©e le rÃ©pertoire nÃ©cessaire pour PHP-FPM en dÃ©marrant puis arrÃªtant le service. C'est une astuce pour s'assurer que le rÃ©pertoire `/run/php` existe, car certaines configurations de PHP-FPM s'attendent Ã  ce qu'il soit prÃ©sent.

```bash
if [[ ${WP_ADMIN_NAME,,} == *"admin"* ]]
then
    echo "Erreur : le nom d'utilisateur administrateur ne peut pas contenir le mot 'admin'"
    exit
fi

if [[ ${WP_ADMIN_PSWD,,} == *${WP_ADMIN_NAME,,}* ]]
then
    echo "Erreur : le mot de passe administrateur ne peut pas contenir le nom d'utilisateur"
    exit
fi
```
Ces vÃ©rifications assurent que le nom d'utilisateur administrateur ne contient pas le mot "admin" et que le mot de passe ne contient pas le nom d'utilisateur. C'est une mesure de sÃ©curitÃ© simple mais efficace.

```bash
sleep 12
```
Cette pause de 12 secondes permet de s'assurer que d'autres services, comme la base de donnÃ©es, sont prÃªts avant de continuer.

```bash
if [ ! -f /var/www/html/wp-config.php ]
then
    echo "wp-config.php non trouvÃ© : installation de WordPress"

    wp core download --allow-root --path=/var/www/html --locale=fr_FR
    wp config create --allow-root --dbname="${MYSQL_DTBS_NAME}" --dbuser="${MYSQL_USER_NAME}" --dbpass="${MYSQL_USER_PSWD}" --dbhost="${WP_DTBS_HOST}"
    wp core install --allow-root --url="${DOMAIN_NAME}" --title="${WP_TITLE}" --admin_name="${WP_ADMIN_NAME}" --admin_password="${WP_ADMIN_PSWD}" --admin_email="${WP_ADMIN_EMAIL}" --skip-email
    wp user create --allow-root "${WP_USER_NAME}" "${WP_USER_EMAIL}" --user_pass="${WP_USER_PSWD}" --role=author

    echo "WordPress installÃ©"
else
    echo "WordPress dÃ©jÃ  tÃ©lÃ©chargÃ© ; installation ignorÃ©e"
fi
```
Cette section est le cÅ“ur du script. Elle vÃ©rifie si WordPress est dÃ©jÃ  installÃ© en cherchant le fichier wp-config.php. Si ce fichier n'existe pas, le script procÃ¨de Ã  l'installation de WordPress :
1. TÃ©lÃ©charge les fichiers de base de WordPress.
2. CrÃ©e le fichier de configuration avec les dÃ©tails de la base de donnÃ©es.
3. Installe WordPress et crÃ©e le compte administrateur.
4. CrÃ©e un utilisateur supplÃ©mentaire avec le rÃ´le d'auteur.

L'utilisation de WP-CLI (`wp`) permet d'automatiser tout ce processus.

```bash
echo "Lancement de PHP-FPM"
/usr/sbin/php-fpm7.3 -F
```
Enfin, le script lance PHP-FPM en premier plan. L'option `-F` est cruciale dans un environnement Docker car elle garde PHP-FPM en premier plan, ce qui est nÃ©cessaire pour que le conteneur reste actif.

Points importants Ã  noter :
1. Le script effectue des vÃ©rifications de sÃ©curitÃ© sur les noms d'utilisateur et mots de passe.
2. Il utilise WP-CLI pour automatiser l'installation et la configuration de WordPress.
3. Il crÃ©e deux types de comptes (administrateur et auteur) pour une meilleure gestion des rÃ´les et des permissions.
4. Le script est idempotent : il ne rÃ©installe pas WordPress s'il est dÃ©jÃ  prÃ©sent.

Ce script est crucial pour notre projet Inception car il assure une installation et une configuration cohÃ©rentes et automatisÃ©es de WordPress dans notre environnement conteneurisÃ©.

## WordPress PHP-FPM Configuration

Je vais vous expliquer en dÃ©tail ce fichier de configuration PHP-FPM que j'ai crÃ©Ã© pour notre projet Inception. Ce fichier, gÃ©nÃ©ralement nommÃ© `www.conf`, dÃ©finit les paramÃ¨tres pour le pool de processus PHP-FPM qui gÃ¨rera notre application WordPress. Voici une explication approfondie de chaque directive :

```
[www]
```
Cette ligne dÃ©finit le dÃ©but d'un pool de processus nommÃ© "www". C'est le pool qui gÃ¨rera les requÃªtes PHP pour notre application WordPress.
Un **pool** dans le contexte de PHP-FPM est un groupe de processus configurÃ© pour traiter les requÃªtes PHP. Chaque pool est dÃ©fini par un ensemble de paramÃ¨tres spÃ©cifiques (comme le nombre de processus, les utilisateurs, les sockets de communication) et peut Ãªtre configurÃ© indÃ©pendamment pour gÃ©rer les requÃªtes d'applications web distinctes. Par exemple, le pool nommÃ© "www" gÃ¨re les requÃªtes PHP pour une application WordPress, optimisant les performances et la sÃ©curitÃ©.

```
user = www-data
group = www-data
```
Ces lignes spÃ©cifient l'utilisateur et le groupe sous lesquels les processus PHP-FPM s'exÃ©cuteront. L'utilisation de "www-data" est une pratique standard pour des raisons de sÃ©curitÃ©.

```
listen = wordpress:9000
```
Cette directive configure PHP-FPM pour Ã©couter sur l'adresse "wordpress" et le port 9000. Dans notre environnement Docker, "wordpress" fait rÃ©fÃ©rence au nom du service WordPress dÃ©fini dans le fichier docker-compose.yml.

```
listen.owner = www-data
listen.group = www-data
```
Ces lignes dÃ©finissent le propriÃ©taire et le groupe du socket d'Ã©coute, assurant que le serveur web (Nginx dans notre cas) a les permissions nÃ©cessaires pour communiquer avec PHP-FPM.

```
pm = dynamic
```
Cette option configure le gestionnaire de processus en mode "dynamic", permettant Ã  PHP-FPM d'ajuster dynamiquement le nombre de processus enfants en fonction de la charge du serveur.

```
pm.max_children = 16
pm.start_servers = 4
pm.min_spare_servers = 2
pm.max_spare_servers = 8
```
Ces directives dÃ©finissent les paramÃ¨tres du gestionnaire de processus :
- `max_children` : nombre maximum de processus enfants
- `start_servers` : nombre de processus Ã  dÃ©marrer initialement
- `min_spare_servers` et `max_spare_servers` : limites pour les processus inactifs

```
chdir = /
```
Cette ligne change le rÃ©pertoire de travail des processus PHP-FPM vers la racine du systÃ¨me de fichiers.

```
clear_env = no
```
Cette directive cruciale empÃªche PHP-FPM de nettoyer les variables d'environnement, permettant aux scripts PHP d'accÃ©der aux variables d'environnement dÃ©finies dans le conteneur Docker.

Points importants Ã  noter :
1. Cette configuration est optimisÃ©e pour un environnement WordPress conteneurisÃ©, offrant un bon Ã©quilibre entre performance et utilisation des ressources.
2. L'utilisation de "wordpress:9000" pour l'Ã©coute montre une intÃ©gration Ã©troite avec l'architecture Docker.
3. Le mode dynamic du gestionnaire de processus permet une adaptation Ã  diffÃ©rentes charges de travail.
4. La directive `clear_env = no` est essentielle pour le fonctionnement correct dans un environnement Docker.

Cette configuration fournit une base solide pour exÃ©cuter WordPress avec PHP-FPM dans notre conteneur Docker, offrant un bon Ã©quilibre entre performance, sÃ©curitÃ© et adaptabilitÃ©.








## 1. TÃ©lÃ©chargement de l'image Debian

Pour commencer la configuration de notre machine virtuelle, nous allons tÃ©lÃ©charger l'image ISO de Debian :

1. Rendez-vous sur le site officiel de Debian : [https://www.debian.org/](https://www.debian.org/)
2. Naviguez vers la section "TÃ©lÃ©chargements" ou "Downloads".
3. Choisissez la version stable la plus rÃ©cente de Debian (au moment de la rÃ©daction, il s'agit de Debian 11 "Bullseye").
4. SÃ©lectionnez l'image ISO appropriÃ©e pour votre architecture (gÃ©nÃ©ralement amd64 pour les systÃ¨mes 64 bits).
5. Lancez le tÃ©lÃ©chargement de l'image ISO.

> Note : Assurez-vous de vÃ©rifier l'intÃ©gritÃ© du fichier tÃ©lÃ©chargÃ© en utilisant les sommes de contrÃ´le fournies sur le site de Debian.


## 2. CrÃ©ation et configuration de la machine virtuelle

AprÃ¨s avoir tÃ©lÃ©chargÃ© l'image Debian, nous allons crÃ©er et configurer notre machine virtuelle :

1. Ouvrez votre logiciel de virtualisation (par exemple, VirtualBox ou VMware).
2. Cliquez sur "Nouvelle machine virtuelle" ou Ã©quivalent.
3. Nommez la machine virtuelle "Debian".
4. SÃ©lectionnez le type "Linux" et la version "Debian 64-bit".
5. Configurez les ressources de la VM :
   - MÃ©moire RAM : 4096 MB (4 GB)
   - CPU : 2 cÅ“urs
   - Stockage : 8 GB de disque dur virtuel
6. Laissez les autres paramÃ¨tres par dÃ©faut.
7. Finalisez la crÃ©ation de la VM.

> Note : Assurez-vous que votre systÃ¨me hÃ´te dispose de suffisamment de ressources pour allouer ces spÃ©cifications Ã  la VM.


## 3. DÃ©marrage de la VM et sÃ©lection de l'image Debian

Une fois la VM crÃ©Ã©e, nous allons la dÃ©marrer et sÃ©lectionner l'image Debian pour l'installation :

1. Dans votre logiciel de virtualisation, sÃ©lectionnez la VM "Debian" que vous venez de crÃ©er.
2. Avant de dÃ©marrer la VM, allez dans les paramÃ¨tres de la machine virtuelle.
3. Dans la section "Stockage" ou "Lecteur", sÃ©lectionnez le lecteur CD/DVD virtuel.
4. Cliquez sur l'icÃ´ne de CD/DVD et choisissez "Choisir un fichier de disque optique virtuel".
5. Naviguez jusqu'Ã  l'emplacement oÃ¹ vous avez tÃ©lÃ©chargÃ© l'image ISO Debian et sÃ©lectionnez-la.
6. Appliquez les changements et fermez la fenÃªtre des paramÃ¨tres.
7. DÃ©marrez la VM.
8. La VM devrait maintenant dÃ©marrer sur l'image Debian, lanÃ§ant ainsi le processus d'installation.

> Note : Assurez-vous que l'ordre de dÃ©marrage dans les paramÃ¨tres du BIOS virtuel donne la prioritÃ© au lecteur CD/DVD pour permettre le boot sur l'image ISO.



## 4. Installation de Debian

Nous allons maintenant procÃ©der Ã  l'installation de Debian en mode normal non graphique. Voici les Ã©tapes clÃ©s de l'installation :

1. Au menu de dÃ©marrage, sÃ©lectionnez "Install" (pas l'option graphique).
2. Configurez les paramÃ¨tres de base :
   - Langue : Choisissez votre prÃ©fÃ©rence
   - Localisation : SÃ©lectionnez votre pays
   - Configuration du clavier : Choisissez la disposition appropriÃ©e
3. Configuration rÃ©seau :
   - Hostname : `debian`
   - Domain Name : laissez vide
4. Configuration des utilisateurs :
   - Root password : Choisissez un mot de passe simple (pour l'environnement de dÃ©veloppement uniquement)
   - Full name for new user : Votre login (ex: `hdupuy`)
   - Username : Confirmez ou modifiez le nom d'utilisateur suggÃ©rÃ©
   - User password : Choisissez un mot de passe simple
5. Partitionnement :
   - MÃ©thode : "Guided - use entire disk"
   - SchÃ©ma : "All files in one partition"
6. Configuration supplÃ©mentaire :
   - Scan extra installation media : Non
   - Miroir HTTPS : Laissez vide
7. SÃ©lection des logiciels :
   - DÃ©cochez toutes les options
   - Cochez uniquement "SSH server"
   > Note : Utilisez la touche Espace pour cocher/dÃ©cocher et EntrÃ©e pour valider
8. Installation du chargeur de dÃ©marrage GRUB :
   - Installer GRUB sur le disque principal : Oui
   - SÃ©lectionnez le disque pour l'installation de GRUB

Une fois l'installation terminÃ©e, la VM va redÃ©marrer. Retirez l'image ISO du lecteur virtuel si nÃ©cessaire pour dÃ©marrer sur le disque dur.

> Attention : L'utilisation de mots de passe simples est uniquement recommandÃ©e pour un environnement de dÃ©veloppement isolÃ©. Pour un environnement de production, utilisez toujours des mots de passe forts.



## 5. Connexion en tant que root

AprÃ¨s le redÃ©marrage de la VM, nous allons nous connecter en tant qu'utilisateur root :

1. Ã€ l'invite de connexion, tapez `root` comme nom d'utilisateur.
2. Appuyez sur EntrÃ©e.
3. Saisissez le mot de passe root que vous avez dÃ©fini lors de l'installation.
   > Attention : Les caractÃ¨res du mot de passe ne s'afficheront pas Ã  l'Ã©cran pour des raisons de sÃ©curitÃ©.
4. Appuyez sur EntrÃ©e pour vous connecter.

> Note : La connexion en tant que root vous donne un contrÃ´le total sur le systÃ¨me. Utilisez ce compte avec prÃ©caution, car toute erreur peut avoir des consÃ©quences importantes sur le systÃ¨me.

> Conseil de sÃ©curitÃ© : Dans un environnement de production, il est gÃ©nÃ©ralement recommandÃ© de dÃ©sactiver la connexion directe en tant que root et d'utiliser sudo pour les tÃ¢ches administratives. Cependant, pour notre environnement de dÃ©veloppement, nous utiliserons root pour simplifier le processus de configuration.


## 6. Installation des paquets nÃ©cessaires et dÃ©marrage de l'environnement graphique

AprÃ¨s la connexion en tant que root, nous allons installer les paquets nÃ©cessaires et dÃ©marrer l'environnement graphique :

```bash
# Mise Ã  jour de la liste des paquets disponibles
apt update

# Installation des paquets nÃ©cessaires
apt install -y sudo ufw docker docker-compose make openbox xinit kitty firefox-esr

# DÃ©marrage de l'environnement graphique
startx
```

Explications des commandes :

1. `apt update` : 
   - Met Ã  jour la liste des paquets disponibles dans les dÃ©pÃ´ts Debian.
   - Assure que nous installons les derniÃ¨res versions des paquets.

2. `apt install -y [paquets]` :
   - Installe les paquets spÃ©cifiÃ©s.
   - L'option `-y` rÃ©pond automatiquement "oui" aux demandes de confirmation.
   - Paquets installÃ©s :
     - `sudo` : Permet l'exÃ©cution de commandes avec des privilÃ¨ges Ã©levÃ©s.
     - `ufw` : Pare-feu facile Ã  configurer.
     - `docker` : Plateforme de conteneurisation.
     - `docker-compose` : Outil pour dÃ©finir et exÃ©cuter des applications Docker multi-conteneurs.
     - `make` : Outil d'automatisation de la compilation.
     - `openbox` : Gestionnaire de fenÃªtres lÃ©ger.
     - `xinit` : Initialise le systÃ¨me X Window.
     - `kitty` : Ã‰mulateur de terminal moderne.
     - `firefox-esr` : Navigateur web Firefox Extended Support Release.

3. `startx` :
   - DÃ©marre l'environnement graphique X Window System.
   - Lance Openbox comme gestionnaire de fenÃªtres.

> Note : L'utilisation de `startx` dÃ©marre une session graphique basique. Dans un environnement de production, on utiliserait gÃ©nÃ©ralement un gestionnaire de connexion graphique.


## 7. Configuration de SSH pour permettre la connexion root

AprÃ¨s avoir quittÃ© l'environnement graphique (clic droit > Exit), nous allons configurer SSH pour permettre la connexion en tant que root :

1. Ouvrez le fichier de configuration SSH :
   ```bash
   nano /etc/ssh/sshd_config
   ```

2. Dans l'Ã©diteur nano, recherchez et dÃ©commentez (retirez le # au dÃ©but) les lignes suivantes :
   ```
   Port 42
   PermitRootLogin yes
   PasswordAuthentication yes
   ```

   > Note : Permettre la connexion root via SSH est gÃ©nÃ©ralement dÃ©conseillÃ© pour des raisons de sÃ©curitÃ©. Cette configuration est utilisÃ©e ici pour simplifier le dÃ©veloppement, mais ne devrait pas Ãªtre utilisÃ©e en production.

3. Sauvegardez et quittez nano :
   - Appuyez sur `Ctrl + X`
   - Puis `Y` pour confirmer la sauvegarde
   - Enfin `Enter` pour confirmer le nom du fichier

4. RedÃ©marrez le service SSH pour appliquer les changements :
   ```bash
   service ssh restart
   service sshd restart
   ```

5. VÃ©rifiez le statut du service SSH :
   ```bash
   service ssh status
   ```

Explications des commandes :
- `nano /etc/ssh/sshd_config` : Ouvre le fichier de configuration SSH dans l'Ã©diteur de texte nano.
- `service ssh restart` et `service sshd restart` : RedÃ©marrent le service SSH pour appliquer les nouvelles configurations.
- `service ssh status` : Affiche l'Ã©tat actuel du service SSH, permettant de vÃ©rifier qu'il fonctionne correctement aprÃ¨s les modifications.

> Attention : Permettre la connexion root via SSH et l'authentification par mot de passe augmente les risques de sÃ©curitÃ©. Cette configuration ne doit Ãªtre utilisÃ©e que dans un environnement de dÃ©veloppement contrÃ´lÃ© et isolÃ©.




TrÃ¨s bien, voici comment nous pouvons documenter ces Ã©tapes de configuration du pare-feu UFW en Markdown :

## 8. Configuration du pare-feu UFW

AprÃ¨s avoir configurÃ© SSH, nous allons maintenant configurer le pare-feu UFW (Uncomplicated Firewall) pour sÃ©curiser notre VM tout en permettant le trafic nÃ©cessaire :

```bash
# VÃ©rifier le statut initial d'UFW
ufw status

# Activer UFW
ufw enable

# Autoriser le trafic HTTPS (port 443)
ufw allow 443

# Autoriser le trafic HTTP (port 80)
ufw allow 80

# Autoriser le trafic sur le port 42 (spÃ©cifique au projet)
ufw allow 42

# VÃ©rifier le statut final d'UFW
ufw status
```

Explications des commandes :

1. `ufw status` : 
   - Affiche l'Ã©tat actuel du pare-feu et les rÃ¨gles configurÃ©es.
   - UtilisÃ© avant et aprÃ¨s la configuration pour voir les changements.

2. `ufw enable` :
   - Active le pare-feu UFW.
   - Vous devrez confirmer cette action, car elle peut potentiellement couper les connexions existantes.

3. `ufw allow [port]` :
   - Autorise le trafic entrant sur le port spÃ©cifiÃ©.
   - 443 : Pour le trafic HTTPS
   - 80 : Pour le trafic HTTP
   - 42 : Port spÃ©cifique au projet (assurez-vous que c'est nÃ©cessaire pour votre application)

> Note : N'oubliez pas d'autoriser le port SSH (gÃ©nÃ©ralement 22) si ce n'est pas dÃ©jÃ  fait, pour maintenir l'accÃ¨s Ã  distance.

> Attention : La configuration du pare-feu est une Ã©tape cruciale pour la sÃ©curitÃ©. Assurez-vous de ne pas vous bloquer l'accÃ¨s Ã  la VM en configurant des rÃ¨gles trop restrictives.





## 9. Configuration de la redirection de ports et connexion SSH Ã  distance

Pour permettre l'accÃ¨s Ã  notre VM depuis la machine hÃ´te, nous devons configurer la redirection de ports dans VirtualBox et vÃ©rifier la connexion SSH.

### 9.1 Configuration de la redirection de ports dans VirtualBox

1. ArrÃªtez la machine virtuelle si elle est en cours d'exÃ©cution.
2. Dans VirtualBox, sÃ©lectionnez votre VM Debian.
3. Cliquez sur "Configuration".
4. Allez dans l'onglet "RÃ©seau".
5. SÃ©lectionnez "AvancÃ©" pour dÃ©velopper les options avancÃ©es.
6. Cliquez sur "Redirection de ports".
7. Ajoutez les rÃ¨gles suivantes :

   | Nom   | Protocole | Port HÃ´te | Port InvitÃ© |
   |-------|-----------|-----------|-------------|
   | SSH   | TCP       | 42        | 42          |
   | HTTP  | TCP       | 80        | 80          |
   | HTTPS | TCP       | 443       | 443         |

8. Cliquez sur "OK" pour sauvegarder les changements.

### 9.2 VÃ©rification du service SSH et connexion Ã  distance

1. RedÃ©marrez la VM.
2. Connectez-vous en tant que root.
3. VÃ©rifiez que le service SSH est actif :
   ```bash
   service ssh status
   ```

4. Sur votre machine hÃ´te, ouvrez un terminal et connectez-vous Ã  la VM via SSH :
   ```bash
   ssh root@localhost -p 42
   ```
5. Entrez le mot de passe root que vous avez dÃ©fini lors de l'installation.

> Note : L'utilisation du port 42 pour SSH est non standard et spÃ©cifique Ã  ce projet. Normalement, SSH utilise le port 22.

> Attention : La connexion SSH en tant que root avec un mot de passe est gÃ©nÃ©ralement dÃ©conseillÃ©e pour des raisons de sÃ©curitÃ©. Dans un environnement de production, utilisez des clÃ©s SSH et un utilisateur non-root avec sudo.

Vous avez maintenant le contrÃ´le de la VM directement depuis votre machine hÃ´te, ce qui facilitera la copie et le collage des commandes pour la suite de la configuration.


## 10. Configuration de sudo et ajout de l'utilisateur au groupe Docker

Dans cette Ã©tape, nous allons configurer sudo pour notre utilisateur et l'ajouter au groupe Docker pour faciliter l'utilisation de Docker sans privilÃ¨ges root.

### 10.1 Configuration de sudo

1. Connectez-vous Ã  la VM en tant que root via SSH :
   ```bash
   ssh root@localhost -p 42
   ```

2. Ouvrez le fichier de configuration sudoers :
   ```bash
   nano /etc/sudoers
   ```

3. Ajoutez la ligne suivante sous `root ALL=(ALL:ALL) ALL` :
   ```
   hdupuy ALL=(ALL:ALL) ALL
   ```
   > Remplacez "hdupuy" par votre nom d'utilisateur.

4. Sauvegardez et quittez nano (Ctrl+X, puis Y, puis Enter).

5. VÃ©rifiez que sudo est bien installÃ© :
   ```bash
   apt install sudo
   ```

### 10.2 Ajout de l'utilisateur au groupe Docker

1. Affichez les groupes actuels de votre utilisateur :
   ```bash
   groups hdupuy
   ```

2. Ajoutez votre utilisateur au groupe Docker :
   ```bash
   sudo usermod -aG docker hdupuy
   ```
   > Remplacez "hdupuy" par votre nom d'utilisateur.

3. VÃ©rifiez Ã  nouveau les groupes pour confirmer l'ajout :
   ```bash
   groups hdupuy
   ```

> Note : L'ajout au groupe Docker permet d'utiliser Docker sans prÃ©fixer chaque commande avec `sudo`. Cependant, cela donne Ã  l'utilisateur des privilÃ¨ges Ã©quivalents Ã  root pour les opÃ©rations Docker.

> Important : AprÃ¨s avoir ajoutÃ© l'utilisateur au groupe Docker, vous devrez vous dÃ©connecter et vous reconnecter pour que les changements prennent effet.


## 11. Test de la configuration et clonage du projet Inception

Dans cette Ã©tape, nous allons tester notre configuration en passant Ã  notre utilisateur normal et cloner le projet Inception depuis GitHub.

### 11.1 Passage Ã  l'utilisateur normal

1. Passez de l'utilisateur root Ã  votre utilisateur normal :
   ```bash
   su hdupuy
   ```
   > Remplacez "hdupuy" par votre nom d'utilisateur.

2. Naviguez vers le rÃ©pertoire personnel de l'utilisateur :
   ```bash
   cd ~/
   ```

### 11.2 Clonage du projet Inception

Voici une commande unique qui crÃ©era tous les fichiers avec leur contenu respectif :

```bash
mkdir -p inception/srcs/requirements/{mariadb,nginx,wordpress} && \
cat << 'EOF' > inception/Makefile
VOLUME_DIR = /home/$(USER)/data
WP_DIR = $(VOLUME_DIR)/wordpress
DB_DIR = $(VOLUME_DIR)/mariadb

DOCKER_FILE = ./srcs/docker-compose.yml

.PHONY: all up down re clean fclean

all: up

$(VOLUME_DIR) $(WP_DIR) $(DB_DIR):
	mkdir -p $@

up: $(WP_DIR) $(DB_DIR)
	docker-compose -f $(DOCKER_FILE) up --build

down:
	docker-compose -f $(DOCKER_FILE) down

re: down up

clean: down
	docker system prune -af --volumes
	sudo rm -rf $(WP_DIR) $(DB_DIR) $(VOLUME_DIR)

fclean: clean
	docker builder prune --all -f

EOF

cat << 'EOF' > inception/srcs/docker-compose.yml
services:

  nginx:
    restart: always
    container_name: nginx
    build:
      dockerfile: Dockerfile
      context: ./requirements/nginx
    volumes:
      - wordpress:/var/www/html
    networks:
      - inception_network
    env_file:
      - .env
    ports:
      - "443:443"
    depends_on:
      - wordpress

  wordpress:
    restart: always
    container_name: wordpress
    build:
      dockerfile: Dockerfile
      context: ./requirements/wordpress
    volumes:
      - wordpress:/var/www/html
    networks:
      - inception_network
    env_file:
      - .env
    ports:
      - 9000:9000
    depends_on:
      - mariadb

  mariadb:
    restart: always
    container_name: mariadb
    build:
      dockerfile: Dockerfile
      context: ./requirements/mariadb
    volumes:
      - mariadb:/var/lib/mysql
    networks:
      - inception_network
    env_file:
      - .env
    ports:
      - 3306:3306

networks:
  inception_network:
    driver: bridge

volumes:
  mariadb:
    name: mariadb
    driver: local
    driver_opts:
      o: bind
      type: none
      device: /home/${USER}/data/mariadb

  wordpress:
    name: wordpress
    driver: local
    driver_opts:
      o: bind
      type: none
      device: /home/${USER}/data/wordpress
EOF

cat << 'EOF' > inception/srcs/requirements/mariadb/50-server.conf
[mysqld]
user = mysql
port = 3306
datadir = /var/lib/mysql
socket = /var/run/mysqld/mysqld.sock
bind-address=*
EOF

cat << 'EOF' > inception/srcs/requirements/mariadb/Dockerfile
FROM debian:buster

RUN apt-get update -y && apt-get -y upgrade
RUN apt-get install -y mariadb-server

COPY init.sh init.sh
COPY 50-server.conf /etc/mysql/mariadb.conf.d/50-server.cnf

RUN chmod +x /init.sh && \
    chmod 600 /etc/mysql/mariadb.conf.d/50-server.cnf && \
    mkdir -p /var/run/mysqld && \
    chmod 777 /var/run/mysqld

EXPOSE 3306

ENTRYPOINT [ "/init.sh" ]
EOF

cat << 'EOF' > inception/srcs/requirements/mariadb/init.sh
#!/bin/bash
chown -R mysql:mysql /var/lib/mysql
mysql_install_db --datadir=/var/lib/mysql --user=mysql --skip-test-db >> /dev/null

echo "Initialisation de la base de donnÃ©es"
mysqld --user=mysql --bootstrap --silent-startup << _EOF_
FLUSH PRIVILEGES;

CREATE DATABASE IF NOT EXISTS \`${WORDPRESS_DATABASE_NAME}\`;
CREATE USER IF NOT EXISTS \`${WORDPRESS_MYSQL_USER}\`@'%' IDENTIFIED BY '${WORDPRESS_MYSQL_PASSWORD}';
GRANT ALL PRIVILEGES ON \`${WORDPRESS_DATABASE_NAME}\`.* TO \`${WORDPRESS_MYSQL_USER}\`@'%';

ALTER USER \`root\`@\`localhost\` IDENTIFIED BY '${MYSQL_ROOT_PASSWORD}';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;

FLUSH PRIVILEGES;
_EOF_

echo "Base de donnÃ©es initialisÃ©e"
exec mysqld_safe
EOF

cat << 'EOF' > inception/srcs/requirements/nginx/Dockerfile
FROM debian:buster

RUN apt-get update -y && apt-get -y upgrade && \
    apt-get install -y openssl nginx && \
    mkdir -p /etc/nginx/ssl && \
    chmod 777 /etc/nginx/ssl && \
    openssl req -newkey rsa:4096 -x509 -sha256 -days 365 -nodes \
       -out /etc/nginx/ssl/server.crt \
       -keyout /etc/nginx/ssl/server.key \
       -subj "/C=FR/ST=Rhone/L=Lyon/O=42_School/OU=42_Lyon/CN=hdupuy.42.fr"

COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 443

CMD [ "nginx", "-g", "daemon off;" ]
EOF

cat << 'EOF' > inception/srcs/requirements/nginx/nginx.conf
server {
    listen 443 ssl;
    listen [::]:443 ssl;

    root /var/www/html;

    index index.php index.html index.htm;

    server_name hdupuy.42.fr;

    ssl_certificate     /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;

    ssl_protocols       TLSv1.2 TLSv1.3;

    location / {
        try_files $uri $uri/ /index.php?$args;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass wordpress:9000;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
    }
}
EOF

cat << 'EOF' > inception/srcs/requirements/wordpress/Dockerfile
FROM debian:buster

ENV DEBIAN_FRONTEND noninteractive

RUN apt-get -y update && apt-get -y upgrade
RUN apt-get -y install \
    wget \
    php-fpm \
    php-mysql \
    mariadb-client

COPY www.conf /etc/php/7.3/fpm/pool.d/

RUN wget https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar && \
    chmod +x wp-cli.phar && \
    mv wp-cli.phar /usr/local/bin/wp

COPY init.sh /init.sh
RUN chmod +x /init.sh

EXPOSE 9000

WORKDIR /var/www/html/

ENTRYPOINT [ "/init.sh" ]
EOF

cat << 'EOF' > inception/srcs/requirements/wordpress/init.sh
#!/bin/bash
if [ ! -d /run/php ]
then
    service php7.3-fpm start
    service php7.3-fpm stop
fi

if [[ ${WORDPRESS_ADMIN_USER,,} == *"admin"* ]]
then
    echo "Erreur : le nom d'utilisateur administrateur ne peut pas contenir le mot 'admin'"
    exit
fi

if [[ ${WORDPRESS_ADMIN_PASSWORD,,} == *${WORDPRESS_ADMIN_USER,,}* ]]
then
    echo "Erreur : le mot de passe administrateur ne peut pas contenir le nom d'utilisateur"
    exit
fi

sleep 12

if [ ! -f /var/www/html/wp-config.php ]
then
    echo "wp-config.php non trouvÃ© : installation de WordPress"
    wp core download --allow-root --path=/var/www/html --locale=fr_FR
    wp config create --allow-root --dbname="${WORDPRESS_DATABASE_NAME}" --dbuser="${WORDPRESS_MYSQL_USER}" --dbpass="${WORDPRESS_MYSQL_PASSWORD}" --dbhost="${WORDPRESS_DATABASE_HOST}"
    wp core install --allow-root --url="${DOMAIN_NAME}" --title="${WORDPRESS_SITE_TITLE}" --admin_name="${WORDPRESS_ADMIN_USER}" --admin_password="${WORDPRESS_ADMIN_PASSWORD}" --admin_email="${WORDPRESS_ADMIN_EMAIL}" --skip-email
    wp user create --allow-root "${WORDPRESS_USER_NAME}" "${WORDPRESS_USER_EMAIL}" --user_pass="${WORDPRESS_USER_PASSWORD}" --role=author
    echo "WordPress installÃ©"
else
    echo "WordPress dÃ©jÃ  tÃ©lÃ©chargÃ© ; installation ignorÃ©e"
fi

echo "Lancement de PHP-FPM"
/usr/sbin/php-fpm7.3 -F
EOF

cat << 'EOF' > inception/srcs/requirements/wordpress/www.conf
[www]
user = www-data
group = www-data
listen = wordpress:9000
listen.owner = www-data
listen.group = www-data
pm = dynamic
pm.max_children = 16
pm.start_servers = 4
pm.min_spare_servers = 2
pm.max_spare_servers = 8
chdir = /
clear_env = no
EOF

chmod +x inception/srcs/requirements/mariadb/init.sh inception/srcs/requirements/wordpress/init.sh
```

Cette commande unique crÃ©era tous les dossiers nÃ©cessaires et les fichiers avec leur contenu respectif. Elle rendra Ã©galement les scripts init.sh exÃ©cutables.

Notez que cette commande suppose que vous Ãªtes dans le rÃ©pertoire parent oÃ¹ vous voulez crÃ©er le dossier `inception`. Si ce n'est pas le cas, ajustez le chemin en consÃ©quence.

AprÃ¨s avoir exÃ©cutÃ© cette commande, vous aurez toute la structure de fichiers nÃ©cessaire pour votre projet Inception.

## Script pour la creation du fichier .env

Voici un script Bash qui vous guidera pour remplir les informations nÃ©cessaires et crÃ©era le fichier .env dans le dossier inception/srcs/ :

```bash
#!/bin/bash

# DÃ©finir le chemin du fichier .env
ENV_FILE="inception/srcs/.env"

# Fonction pour demander une valeur Ã  l'utilisateur
ask_value() {
    local prompt="$1"
    local value

    while true; do
        read -p "$prompt : " value
        if [ -n "$value" ]; then
            echo "$value"
            break
        else
            echo "Cette valeur ne peut pas Ãªtre vide. Veuillez rÃ©essayer."
        fi
    done
}

# CrÃ©er le dossier si nÃ©cessaire
mkdir -p "$(dirname "$ENV_FILE")"

# Demander les valeurs Ã  l'utilisateur
echo "Veuillez fournir les informations suivantes pour le fichier .env :"

DOMAIN_NAME=$(ask_value "Nom de domaine")
WORDPRESS_DATABASE_NAME=$(ask_value "Nom de la base de donnÃ©es WordPress")
WORDPRESS_MYSQL_USER=$(ask_value "Utilisateur MySQL WordPress")
WORDPRESS_MYSQL_PASSWORD=$(ask_value "Mot de passe MySQL WordPress")
MYSQL_ROOT_PASSWORD=$(ask_value "Mot de passe root MySQL")
WORDPRESS_DATABASE_HOST=$(ask_value "HÃ´te de la base de donnÃ©es WordPress")
WORDPRESS_SITE_TITLE=$(ask_value "Titre du site WordPress")
WORDPRESS_ADMIN_USER=$(ask_value "Utilisateur admin WordPress")
WORDPRESS_ADMIN_EMAIL=$(ask_value "Email admin WordPress")
WORDPRESS_ADMIN_PASSWORD=$(ask_value "Mot de passe admin WordPress")
WORDPRESS_USER_NAME=$(ask_value "Nom d'utilisateur WordPress")
WORDPRESS_USER_EMAIL=$(ask_value "Email utilisateur WordPress")
WORDPRESS_USER_PASSWORD=$(ask_value "Mot de passe utilisateur WordPress")

# CrÃ©er le fichier .env
cat << EOF > "$ENV_FILE"
DOMAIN_NAME=$DOMAIN_NAME

WORDPRESS_DATABASE_NAME=$WORDPRESS_DATABASE_NAME
WORDPRESS_MYSQL_USER=$WORDPRESS_MYSQL_USER
WORDPRESS_MYSQL_PASSWORD=$WORDPRESS_MYSQL_PASSWORD
MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD

WORDPRESS_DATABASE_HOST=$WORDPRESS_DATABASE_HOST
WORDPRESS_SITE_TITLE=$WORDPRESS_SITE_TITLE

WORDPRESS_ADMIN_USER=$WORDPRESS_ADMIN_USER
WORDPRESS_ADMIN_EMAIL=$WORDPRESS_ADMIN_EMAIL
WORDPRESS_ADMIN_PASSWORD=$WORDPRESS_ADMIN_PASSWORD

WORDPRESS_USER_NAME=$WORDPRESS_USER_NAME
WORDPRESS_USER_EMAIL=$WORDPRESS_USER_EMAIL
WORDPRESS_USER_PASSWORD=$WORDPRESS_USER_PASSWORD
EOF

echo "Le fichier .env a Ã©tÃ© crÃ©Ã© avec succÃ¨s dans $ENV_FILE"
```

Pour utiliser ce script :

1. Copiez ce code dans un nouveau fichier, par exemple `create_env.sh`.

2. Rendez le script exÃ©cutable :
   ```
   chmod +x create_env.sh
   ```

3. ExÃ©cutez le script :
   ```
   ./create_env.sh
   ```

Le script va vous guider en vous demandant de remplir chaque champ. Il proposera des valeurs par dÃ©faut (celles que vous avez fournies) entre crochets. Si vous appuyez simplement sur EntrÃ©e sans rien taper, la valeur par dÃ©faut sera utilisÃ©e.

Une fois que vous avez rempli toutes les informations, le script crÃ©era le fichier .env dans le dossier inception/srcs/ avec les valeurs que vous avez fournies.

Ce script offre plusieurs avantages :
- Il guide l'utilisateur Ã  travers chaque champ.
- Il crÃ©e automatiquement le dossier si nÃ©cessaire.
- Il assure que le fichier .env est crÃ©Ã© au bon endroit avec le bon contenu.

N'oubliez pas de garder ce fichier .env sÃ©curisÃ©, car il contient des informations sensibles comme des mots de passe.

## Redirection de localhost vers login.42.fr

Pour faire en sorte que hdupuy.42.fr renvoie sur localhost sur Linux, vous pouvez modifier le fichier `/etc/hosts`. Voici les Ã©tapes Ã  suivre :

1. Ouvrez un terminal.

2. Utilisez un Ã©diteur de texte avec des privilÃ¨ges root pour modifier le fichier `/etc/hosts`. Par exemple, avec nano :

   ```
   sudo nano /etc/hosts
   ```

3. Ajoutez la ligne suivante Ã  la fin du fichier :

   ```
   127.0.0.1   hdupuy.42.fr
   ```

4. Sauvegardez le fichier et quittez l'Ã©diteur. Dans nano, vous pouvez faire cela en appuyant sur Ctrl+X, puis Y, et enfin Enter.

5. Pour que les changements soient pris en compte immÃ©diatement, vous pouvez vider le cache DNS de votre systÃ¨me. Sur la plupart des systÃ¨mes Linux, vous pouvez le faire en redÃ©marrant le service de rÃ©solution de noms :

   ```
   sudo /etc/init.d/networking restart
   ```

AprÃ¨s ces Ã©tapes, toutes les requÃªtes vers hdupuy.42.fr seront redirigÃ©es vers votre machine locale (localhost).


## 12. Lancement du projet Inception avec Docker Compose

Cette Ã©tape finale consiste Ã  naviguer dans le bon rÃ©pertoire et Ã  lancer le projet Inception en utilisant Docker Compose.

1. Naviguez vers le rÃ©pertoire `srcs` Ã  l'intÃ©rieur du dossier `inception` :
   ```bash
   cd inception/srcs
   ```

2. Lancez le projet en utilisant Docker Compose :
   ```bash
   docker-compose -f docker-compose.yml up --build
   ```
3. Vous pouvez lancer le projet en utilisant le Makefile fourni :
   ```bash
   make
   ```

Explications de la commande :
- `docker-compose` : Outil pour dÃ©finir et exÃ©cuter des applications Docker multi-conteneurs.
- `-f docker-compose.yml` : SpÃ©cifie le fichier de configuration Docker Compose Ã  utiliser.
- `up` : CrÃ©e et dÃ©marre les conteneurs dÃ©finis dans le docker-compose.yml.
- `--build` : Force Docker Compose Ã  reconstruire les images avant de dÃ©marrer les conteneurs.

> Note : Cette commande va construire les images Docker si nÃ©cessaire, puis dÃ©marrer tous les services dÃ©finis dans votre fichier docker-compose.yml. Le processus peut prendre plusieurs minutes, surtout lors de la premiÃ¨re exÃ©cution.

> Conseil : Gardez un Å“il sur la sortie de la console pour dÃ©tecter d'Ã©ventuelles erreurs ou messages importants pendant le dÃ©marrage des services.

Pour arrÃªter les conteneurs, vous pouvez utiliser Ctrl+C dans le terminal oÃ¹ Docker Compose est en cours d'exÃ©cution.

Si vous voulez exÃ©cuter les conteneurs en arriÃ¨re-plan, vous pouvez ajouter l'option `-d` Ã  la commande :
```bash
docker-compose -f docker-compose.yml up --build -d
```

Pour arrÃªter et supprimer les conteneurs en arriÃ¨re-plan, utilisez :
```bash
docker-compose -f docker-compose.yml down
```

Pour vÃ©rifier si les deux utilisateurs (l'utilisateur WordPress et l'utilisateur root) ont bien Ã©tÃ© crÃ©Ã©s dans la base de donnÃ©es MariaDB, vous pouvez suivre ces Ã©tapes :

1. Connectez-vous au conteneur MariaDB :
   ```
   docker exec -it [nom_du_conteneur_mariadb] bash
   ```

2. Connectez-vous Ã  MariaDB en tant que root :
   ```
   mysql -u root -p
   ```
   Entrez le mot de passe root que vous avez dÃ©fini (${MYSQL_ROOT_PASSWORD}).

3. Une fois connectÃ©, vous pouvez vÃ©rifier les utilisateurs avec la commande suivante :
   ```sql
   SELECT User, Host FROM mysql.user;
   ```

4. Pour vÃ©rifier les privilÃ¨ges de l'utilisateur WordPress :
   ```sql
   SHOW GRANTS FOR '[WORDPRESS_MYSQL_USER]'@'%';
   ```
   Remplacez [WORDPRESS_MYSQL_USER] par le nom d'utilisateur que vous avez dÃ©fini.

5. VÃ©rifiez Ã©galement que la base de donnÃ©es WordPress a Ã©tÃ© crÃ©Ã©e :
   ```sql
   SHOW DATABASES;
   ```

6. Pour vÃ©rifier que l'utilisateur WordPress a bien les droits sur la base de donnÃ©es :
   ```sql
   SHOW GRANTS FOR '[WORDPRESS_MYSQL_USER]'@'%';
   ```
